{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"iTmpl","text":"<p> iTmpl. A flexible, powerful project templating tool, written in Python. </p> <p>Documentation: https://itmpl.ihh.dev</p> <p>Source: https://github.com/isaacharrisholt/itmpl</p> <p>iTmpl is a project templating tool that allows you to create and manage project templates. iTmpl is written in Python and is cross-platform.</p> <p>It comes with some default templates, but you can also create your own. iTmpl also allows you to run arbitrary Python code before and after the templating process, allowing you to do things like create a git repository, or install dependencies.</p>"},{"location":"#installation","title":"Installation","text":"<p>Although iTmpl has a well-documented API, its primary aim it to be a command line tool. As such, the recommended installation method is via <code>pipx</code>:</p> <pre><code>pipx install itmpl\n</code></pre> <p>However, you can also install iTmpl via <code>pip</code>, if you prefer:</p> <pre><code>pip install itmpl\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>To see available project templates, run:</p> <pre><code>itmpl list\n</code></pre> <p>If the template you'd like to use has dependencies, run <code>itmpl deps &lt;template&gt;</code> to install them to the environment iTmpl is running in.</p> <p>To create a new project from a template, run:</p> <pre><code>itmpl new &lt;template&gt; &lt;project-name&gt; [options]\n</code></pre> <p>For example, to create a new Poetry project, run:</p> <pre><code>itmpl new poetry-project my-new-project\n</code></pre>"},{"location":"#adding-custom-templates","title":"Adding Custom Templates","text":"<p>Custom templates are stored in an <code>extra_templates_dir</code> specified in the iTmpl configuration file. To find the default location for your machine, run:</p> <pre><code>itmpl config show extra_templates_dir\n</code></pre> <p>To change the location of the <code>extra_templates_dir</code>, run:</p> <pre><code>itmpl config set extra_templates_dir &lt;path&gt;\n</code></pre> <p>To create a new template, simple create a new directory in the <code>extra_templates_dir</code>. iTmpl will automatically detect the new template, and show it in the list of available templates.</p> <p>Templates can be configured through <code>.itmpl.toml</code> and <code>.itmpl.py</code> files. See the documentation for more details.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! If you find a bug, or have a feature request, please open a new issue. If you would like to contribute code, please open a new pull request.</p> <p>I'm always open to new templates too! I don't know every possible use case for this tool, so I've only included a few templates that I thought would be useful to me. If you have a template that you think would be useful to others, please open a new issue, or submit a pull request!</p>"},{"location":"using_custom_templates/","title":"Using Custom Templates","text":"<p>Custom templates are stored in an <code>extra_templates_dir</code> specified in the iTmpl configuration file. To find the default location for your machine, run:</p> <pre><code>itmpl config show extra_templates_dir\n</code></pre> <p>To change the location of the <code>extra_templates_dir</code>, run:</p> <pre><code>itmpl config set extra_templates_dir &lt;path&gt;\n</code></pre> <p>To create a new template, simple create a new directory in the <code>extra_templates_dir</code>. iTmpl will automatically detect the new template, and show it in the list of available templates.</p>"},{"location":"using_custom_templates/#the-templating-flow","title":"The Templating Flow","text":"<p>The templating flow is as follows:</p> <ol> <li>The template directory is cloned to a temporary directory.</li> <li> <p>iTmpl gathers templating variables. There are three places it will gather    from, in order of precedence:</p> <ul> <li>The <code>get_variables</code> function in the <code>.itmpl.py</code> file.</li> <li>The <code>variables</code> table in the <code>.itmpl.toml</code> file.</li> <li>The default variables provided by iTmpl.</li> </ul> </li> <li> <p>iTmpl renders the template files with Jinja2 using the templating variables.    Any undefined variables will be left as is on this pass.</p> </li> <li>The templated directory is copied to the destination directory.</li> <li> <p>iTmpl runs the <code>post_script</code> function in the <code>.itmpl.py</code> file, if present.    If this returns any variables, iTmpl will render the template files again    with the new variables.</p> <ul> <li>You can use this to install dependencies, or run any other post-templating   script.</li> <li>Note: on the second pass, Jinja2 will throw an error if the template   contains any undefined variables.</li> </ul> </li> <li> <p>Any files or directories matching <code>.itmpl*</code> are removed from the destination    directory. <code>__pycache__</code> directories are also removed.</p> <ul> <li>It is recommended to prefix any files or directories that you do not want   to remain the destination directory with <code>.itmpl</code>, e.g. requirements   files.</li> </ul> </li> </ol>"},{"location":"using_custom_templates/#default-variables","title":"Default Variables","text":"<p>iTmpl provides a set of default variables that are available to all templates.</p> Variable Name Description <code>project_name</code> The name of the project, as entered by the user. <code>project_title</code> The project name, with underscores replaced with spaces and in title case (e.g. <code>my_project</code> -&gt; <code>My Project</code>). <code>current_year</code> The current year. <code>current_datetime</code> The current date and time in isoformat, with a resolution of seconds (e.g. <code>2023-01-01 12:34:56</code>)."},{"location":"using_custom_templates/#the-itmplpy-file","title":"The <code>.itmpl.py</code> File","text":"<p>The <code>.itmpl.py</code> file is used to store Python code that is used to configure the templating process. Code in the <code>.itmpl.py</code> file is imported by iTmpl during templating, and therefore has access to all of iTmpl's functionality and any libraries installed in the iTmpl environment.</p> <p>This includes Typer, which can be used to prompt the user for input.</p> <p>You don't have to provide an <code>.itmpl.py</code> file, but if you do, it can contain any combination of the following functions:</p> Function Name Description <code>get_variables</code> A function that returns a <code>Dict[str, Any]</code> object containing variables used in templating. You can use this to prompt the user for input, or define a computed variable. <code>post_script</code> A function that runs in the final project directory, and returns a <code>Dict[str, Any]</code> of variables to use in the second rendering pass. You can use this to install requirements, for example. <p>Note: you can include any combination of the above functions in the <code>.itmpl.py</code> file.</p>"},{"location":"using_custom_templates/#function-signatures","title":"Function Signatures","text":""},{"location":"using_custom_templates/#get_variables","title":"<code>get_variables</code>","text":"<pre><code>def get_variables(\nproject_name: str,  # (1)!\ndestination: Path,  # (2)!\nvariables: Dict[str, Any],  # (3)!\n) -&gt; Dict[str, Any]:  # (4)!\n...\n</code></pre> <ol> <li>The project name, as entered by the user.</li> <li>The destination directory.</li> <li>iTmpl's default variables, plus any variables defined in the <code>.itmpl.toml</code>    file.</li> <li>The variables to use in templating. These will be combined with the    variables passed into the function, with the Python-defined variables taking    precedence.</li> </ol>"},{"location":"using_custom_templates/#post_script","title":"<code>post_script</code>","text":"<pre><code>def post_script(\nproject_name: str,  # (1)!\nfinal_directory: Path,  # (2)!\nvariables: Dict[str, Any],  # (3)!\n) -&gt; Optional[Dict[str, Any]]:  # (4)!\n...\n</code></pre> <ol> <li>The project name, as entered by the user.</li> <li>The final project directory.</li> <li>Any variables used in the first templating pass.</li> <li>The variables to use in the second templating pass. If this function returns    a falsy value (e.g. <code>None</code>, <code>{}</code>), iTmpl will not run the second pass.</li> </ol>"},{"location":"using_custom_templates/#the-itmpltoml-file","title":"The <code>.itmpl.toml</code> File","text":"<p>The <code>.itmpl.toml</code> file is an optional file used to store metadata and default variables for the template. The following is an example <code>.itmpl.toml</code> file:</p> <pre><code>[metadata]\ntemplate_description = \"A template for creating a Python package with Poetry.\"\ntemplate_requirements = [\"poetry\", \"pyyaml\"]\n[variables]\nauthor = \"Isaac Harris-Holt\"\nwebsite = \"https://itmpl.ihh.dev/\"\n</code></pre>"},{"location":"using_custom_templates/#metadata","title":"Metadata","text":"<p>The <code>metadata</code> table is used to store metadata about the template. The following metadata fields are available:</p> Field Name Description <code>template_description</code> A description of the template. This is used in <code>itmpl list</code> to display the purpose of the template. <code>template_requirements</code> A list of requirements for the template. This is used in <code>itmpl list</code> to display the requirements, and <code>itmpl deps</code> to install project dependencies. <code>templating_excludes</code> A list of glob patterns to exclude from templating. This is useful if you have files that you don't want to be templated, but still want to be copied to the destination directory."},{"location":"using_custom_templates/#variables","title":"Variables","text":"<p>The <code>variables</code> table is used to store default variables for the template. The variables are passed to Jinja2 as a <code>Dict[str, Any]</code> object. You may define whatever variables you like, and can use this to set defaults used in your template.</p> <p>This is useful when you have a variable that doesn't often change, like the current version of Python, so you don't need to prompt the user for it during templating, but may want to change it in the future.</p>"},{"location":"reference/","title":"itmpl","text":"<p>iTmpl is a powerful project templating CLI tool, written in Python.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>itmpl<ul> <li>config</li> <li>global_vars</li> <li>main</li> <li>metadata</li> <li>templating</li> <li>tree_utils</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/config/","title":"config","text":""},{"location":"reference/config/#itmpl.config.Config","title":"Config","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for iTmpl.</p> Source code in <code>itmpl/config.py</code> <pre><code>class Config(BaseModel):\n\"\"\"Configuration for iTmpl.\"\"\"\nextra_templates_dir: Path = APP_DIR / \"templates\"\n</code></pre>"},{"location":"reference/config/#itmpl.config.show","title":"show","text":"<pre><code>show(option=typer.Argument(None))\n</code></pre> <p>Show the current configuration.</p> Source code in <code>itmpl/config.py</code> <pre><code>@app.command(\"show\")\ndef show(option: ConfigOption = typer.Argument(None)):  # type: ignore\n\"\"\"Show the current configuration.\"\"\"\nconfig = read_config()\nif option:\nprint(config.__getattribute__(option.value))\nreturn\nprint(config.json(indent=4))\n</code></pre>"},{"location":"reference/config/#itmpl.config.set_","title":"set_","text":"<pre><code>set_(option, value)\n</code></pre> <p>Set a configuration option.</p> Source code in <code>itmpl/config.py</code> <pre><code>@app.command(\"set\")\ndef set_(\noption: ConfigOption,  # type: ignore\nvalue: str,\n):\n\"\"\"Set a configuration option.\"\"\"\nconfig = read_config()\n# Some custom validation using Pydantic's ModelField validation\nmodel_field: ModelField = config.__fields__[option.value]\nother_attrs = {k: v for k, v in config.__dict__.items() if k != option.value}\nnew, error = model_field.validate(value, other_attrs, loc=option.value, cls=Config)\nif error:\nraise typer.BadParameter(\nf\"{value} is not a valid {model_field.type_.__name__}\",\nparam_hint=option.value,\n)\nif new and model_field.type_ == Path and not (new.exists() and new.is_dir()):\nraise typer.BadParameter(\nf\"{value} is not a valid directory\",\nparam_hint=option.value,\n)\nconfig.__setattr__(option.value, new)\nwrite_config(config)\nprint(f\"Set [green]{option.value}[/green] to [green]{new}[/green]\")\n</code></pre>"},{"location":"reference/config/#itmpl.config.get","title":"get","text":"<pre><code>get(option)\n</code></pre> <p>Get a configuration option.</p> Source code in <code>itmpl/config.py</code> <pre><code>@app.command()\ndef get(option: ConfigOption):  # type: ignore\n\"\"\"Get a configuration option.\"\"\"\nconfig = read_config()\nprint(\nf\"[green]{option.value}[/green] is set to \"\nf\"[green]{config.__getattribute__(option.value)}[/green]\"\n)\n</code></pre>"},{"location":"reference/config/#itmpl.config.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the configuration to the default values.</p> Source code in <code>itmpl/config.py</code> <pre><code>@app.command()\ndef reset():\n\"\"\"Reset the configuration to the default values.\"\"\"\ntyper.confirm(\"Are you sure you want to reset the configuration?\", abort=True)\nwrite_config(Config())\nprint(\"Reset configuration to default values.\")\n</code></pre>"},{"location":"reference/global_vars/","title":"global_vars","text":""},{"location":"reference/main/","title":"main","text":""},{"location":"reference/main/#itmpl.main.list_","title":"list_","text":"<pre><code>list_()\n</code></pre> <p>List all available templates.</p> Source code in <code>itmpl/main.py</code> <pre><code>@app.command(\"list\")\ndef list_():\n\"\"\"List all available templates.\"\"\"\nprint(\nutils.construct_table_from_templates(\ntemplating.get_template_options().values(),\n),\n)\n</code></pre>"},{"location":"reference/main/#itmpl.main.new","title":"new","text":"<pre><code>new(\ntemplate,\nname,\npath=typer.Option(\nPath(\".\"),\n\"--path\",\n\"-p\",\nexists=True,\nhelp=\"The path to create the project in.\",\n),\nforce=typer.Option(\nFalse,\n\"--force\",\n\"-f\",\nhelp=\"Overwrite any files that already exist without prompting.\",\n),\n)\n</code></pre> <p>Create a new project from a template.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>str</code> <p>The name of the template to use.</p> required <code>name</code> <code>str</code> <p>The name of the project to create.</p> required <code>path</code> <code>Path</code> <p>The path to create the project in.</p> <code>typer.Option(Path('.'), '--path', '-p', exists=True, help='The path to create the project in.')</code> <code>force</code> <code>bool</code> <p>If True, overwrite any files that already exist without prompting.</p> <code>typer.Option(False, '--force', '-f', help='Overwrite any files that already exist without prompting.')</code> Source code in <code>itmpl/main.py</code> <pre><code>@app.command()\ndef new(\ntemplate: str,\nname: str,\npath: Path = typer.Option(\nPath(\".\"),\n\"--path\",\n\"-p\",\nexists=True,\nhelp=\"The path to create the project in.\",\n),\nforce: bool = typer.Option(\nFalse,\n\"--force\",\n\"-f\",\nhelp=\"Overwrite any files that already exist without prompting.\",\n),\n):\n\"\"\"Create a new project from a template.\n    Parameters\n    ----------\n    template : str\n        The name of the template to use.\n    name : str\n        The name of the project to create.\n    path : Path\n        The path to create the project in.\n    force : bool\n        If True, overwrite any files that already exist without prompting.\n    \"\"\"\ntry:\ntemplate_options = templating.get_template_options()\nexcept templating.DuplicateTemplateError as e:\nprint(\"[red]Duplicate templates found:[/red]\")\nprint(utils.construct_table_from_templates(e.duplicate_templates.values()))\nprint(\"[red]Please remove the duplicates and try again.[/red]\")\nraise typer.Exit(1)\nif template not in template_options:\nprint(\nf\"[red]Template [white]{template}[/white] not found. \"\nf\"Available templates:[/red]\"\n)\nprint(utils.construct_table_from_templates(template_options.values()))\nraise typer.Exit(1)\n# Allow the user to template in this directory\npath = path.resolve()\nif path.name == name:\npath = path.parent\ndestination = path / name\ntemplate_path = template_options[template][0]\ntemplate_metadata = template_options[template][1]\ntry:\ntemplating.render_template(\nproject_name=name,\ntemplate=template,\ndestination=destination,\ntemplate_path=template_path,\nexclude=template_metadata.metadata.templating_excludes,\nprompt_if_duplicates=not force,\n)\nexcept templating.TemplatingException as e:\nprint(f\"[red]Error when templating project:[/red] {e}\")\nraise typer.Exit(1)\nprint(f\"Created [green]{template}[/green] project at [green]{destination}[/green]\")\n</code></pre>"},{"location":"reference/main/#itmpl.main.deps","title":"deps","text":"<pre><code>deps(template=typer.Argument(None))\n</code></pre> <p>Install dependencies for the specified template. If no template is specified, install dependencies for all templates.</p> Source code in <code>itmpl/main.py</code> <pre><code>@app.command()\ndef deps(template: Optional[str] = typer.Argument(None)):\n\"\"\"Install dependencies for the specified template. If no template is specified,\n    install dependencies for all templates.\"\"\"\ntry:\ntemplate_options = templating.get_template_options()\nexcept templating.DuplicateTemplateError as e:\nprint(\"[red]Duplicate templates found:[/red]\")\nprint(utils.construct_table_from_templates(e.duplicate_templates.values()))\nprint(\"[red]Please remove the duplicates and try again.[/red]\")\nraise typer.Exit(1)\nif template is not None and template not in template_options:\nprint(\nf\"[red]Template [white]{template}[/white] not found. \"\nf\"Available templates:[/red]\"\n)\nprint(utils.construct_table_from_templates(template_options.values()))\nraise typer.Exit(1)\nif template is None:\ntemplates_with_dependencies = [\n(template_name, toml_obj.metadata.template_requirements)\nfor template_name, (_, toml_obj) in template_options.items()\n]\nelse:\ntemplates_with_dependencies = [\n(template, template_options[template][1].metadata.template_requirements),\n]\nto_install = [\n(template_name, dependencies)\nfor template_name, dependencies in templates_with_dependencies\nif dependencies\n]\nif not to_install:\nprint(\"[green]No dependencies to install.[/green]\")\nraise typer.Exit(0)\nfor template_name, dependencies in to_install:\nprint(\nf\"[green]Installing dependencies for template \"\nf\"[white]{template_name}[/white][/green]\"\n)\ntry:\nutils.install_dependencies(dependencies)\nexcept subprocess.CalledProcessError as e:\nprint(\nf\"[red]Error installing dependencies for template \"\nf\"[white]{template_name}[/white]: {e}[/red]\"\n)\nprint(\"[green]Done.[/green]\")\n</code></pre>"},{"location":"reference/main/#itmpl.main.create_directories","title":"create_directories","text":"<pre><code>create_directories()\n</code></pre> <p>Create directories used by iTmpl. This is called automatically when iTmpl is run.</p> Source code in <code>itmpl/main.py</code> <pre><code>@app.callback()\ndef create_directories():\n\"\"\"Create directories used by iTmpl. This is called automatically when iTmpl is\n    run.\"\"\"\nglobal_vars.APP_DIR.mkdir(parents=True, exist_ok=True)\nglobal_vars.TEMPLATES_DIR.mkdir(parents=True, exist_ok=True)\nc = config.read_config()\nc.extra_templates_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"reference/metadata/","title":"metadata","text":""},{"location":"reference/metadata/#itmpl.metadata.ItmplMetadata","title":"ItmplMetadata","text":"<p>         Bases: <code>BaseModel</code></p> <p>Metadata from the .itmpl.toml file.</p> Source code in <code>itmpl/metadata.py</code> <pre><code>class ItmplMetadata(BaseModel):\n\"\"\"Metadata from the .itmpl.toml file.\"\"\"\ntemplate_description: Optional[str] = None\ntemplate_requirements: List[str] = []\ntemplating_excludes: List[str] = []\n</code></pre>"},{"location":"reference/metadata/#itmpl.metadata.ItmplToml","title":"ItmplToml","text":"<p>         Bases: <code>BaseModel</code></p> <p>The whole contents of the .itmpl.toml file.</p> Source code in <code>itmpl/metadata.py</code> <pre><code>class ItmplToml(BaseModel):\n\"\"\"The whole contents of the .itmpl.toml file.\"\"\"\nmetadata: ItmplMetadata = ItmplMetadata()\nvariables: Dict[str, Any] = {}\n</code></pre>"},{"location":"reference/templating/","title":"templating","text":""},{"location":"reference/templating/#itmpl.templating.DuplicateTemplateError","title":"DuplicateTemplateError","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when there are duplicate templates.</p> Source code in <code>itmpl/templating.py</code> <pre><code>class DuplicateTemplateError(Exception):\n\"\"\"Exception raised when there are duplicate templates.\"\"\"\ndef __init__(\nself,\nduplicate_templates: Dict[str, Tuple[Path, ItmplToml]],\n) -&gt; None:\nsuper().__init__()\nself.duplicate_templates = duplicate_templates\n</code></pre>"},{"location":"reference/templating/#itmpl.templating.IgnoreUndefined","title":"IgnoreUndefined","text":"<p>         Bases: <code>jinja2.Undefined</code></p> <p>Ignore undefined variables.</p> Source code in <code>itmpl/templating.py</code> <pre><code>class IgnoreUndefined(jinja2.Undefined):\n\"\"\"Ignore undefined variables.\"\"\"\ndef __str__(self):\nif not self._undefined_name:\nreturn \"\"\nreturn \"{{ \" + self._undefined_name + \" }}\"\n</code></pre>"},{"location":"reference/templating/#itmpl.templating.TemplatingException","title":"TemplatingException","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when there is an error with the templating.</p> Source code in <code>itmpl/templating.py</code> <pre><code>class TemplatingException(Exception):\n\"\"\"Exception raised when there is an error with the templating.\"\"\"\n</code></pre>"},{"location":"reference/templating/#itmpl.templating.get_templates_in_dir","title":"get_templates_in_dir","text":"<pre><code>get_templates_in_dir(directory)\n</code></pre> <p>Return a list of templates in a directory with their descriptions.</p> Source code in <code>itmpl/templating.py</code> <pre><code>def get_templates_in_dir(directory: Path) -&gt; Dict[str, Tuple[Path, ItmplToml]]:\n\"\"\"Return a list of templates in a directory with their descriptions.\"\"\"\ntemplates = {}\nfor path in directory.iterdir():\nif not path.is_dir():\ncontinue\ntoml_obj = metadata.read_itmpl_toml(path / \".itmpl.toml\")\ntemplates[path.name] = (path, toml_obj)\nreturn templates\n</code></pre>"},{"location":"reference/templating/#itmpl.templating.get_template_options","title":"get_template_options","text":"<pre><code>get_template_options()\n</code></pre> <p>Return a list of template options and their descriptions.</p> Source code in <code>itmpl/templating.py</code> <pre><code>def get_template_options() -&gt; Dict[str, Tuple[Path, ItmplToml]]:\n\"\"\"Return a list of template options and their descriptions.\"\"\"\nc = config.read_config()\ndefault_template_options = get_templates_in_dir(global_vars.TEMPLATES_DIR)\nextra_template_options = get_templates_in_dir(c.extra_templates_dir)\n# Find the intersection of the two sets of templates\nduplicate_template_keys = (\ndefault_template_options.keys() &amp; extra_template_options.keys()\n)\nduplicate_templates = {\nk: v\nfor k, v in default_template_options.items()\nif k in duplicate_template_keys\n}\nif duplicate_templates:\nraise DuplicateTemplateError(duplicate_templates)\nreturn {**default_template_options, **extra_template_options}\n</code></pre>"},{"location":"reference/templating/#itmpl.templating.get_toml_variables","title":"get_toml_variables","text":"<pre><code>get_toml_variables(temp_directory)\n</code></pre> <p>Get extra variables from the .itmpl.toml file in the template directory.</p> Source code in <code>itmpl/templating.py</code> <pre><code>def get_toml_variables(temp_directory: Path) -&gt; Dict[str, Any]:\n\"\"\"Get extra variables from the .itmpl.toml file in the template directory.\"\"\"\ntry:\nmeta = metadata.read_itmpl_toml(temp_directory / \".itmpl.toml\")\nexcept ValidationError as e:\nraise TemplatingException(f\"Error when validating .itmpl.toml: {e}\") from e\nexcept Exception as e:\nraise TemplatingException(f\"Error when reading .itmpl.toml: {e}\") from e\nreturn meta.variables\n</code></pre>"},{"location":"reference/templating/#itmpl.templating.get_python_variables","title":"get_python_variables","text":"<pre><code>get_python_variables(\ntemp_directory, project_name, destination, variables\n)\n</code></pre> <p>Get extra variables from the .itmpl.py file in the template directory.</p> Source code in <code>itmpl/templating.py</code> <pre><code>def get_python_variables(\ntemp_directory: Path,\nproject_name: str,\ndestination: Path,\nvariables: Dict[str, Any],\n) -&gt; Dict[str, str]:\n\"\"\"Get extra variables from the .itmpl.py file in the template directory.\"\"\"\nmodule = _setup_itmpl_module(temp_directory)\nif not module or not hasattr(module, \"get_variables\"):\nreturn {}\ntry:\nreturn module.get_variables(\nproject_name,\ndestination,\nvariables,\n)\nexcept Exception as e:\nraise TemplatingException(\nf\"Error when getting extra variables from .itmpl.py: {e}\"\n) from e\n</code></pre>"},{"location":"reference/templating/#itmpl.templating.run_post_script","title":"run_post_script","text":"<pre><code>run_post_script(project_name, final_directory, variables)\n</code></pre> <p>Run the post script in the .itmpl.py file in the template directory.</p> Source code in <code>itmpl/templating.py</code> <pre><code>def run_post_script(\nproject_name: str,\nfinal_directory: Path,\nvariables: Dict[str, str],\n) -&gt; Dict[str, str]:\n\"\"\"Run the post script in the .itmpl.py file in the template directory.\"\"\"\nmodule = _setup_itmpl_module(final_directory)\nif not module or not hasattr(module, \"post_script\"):\nreturn {}\ntry:\nreturn module.post_script(\nproject_name,\nfinal_directory,\nvariables,\n)\nexcept Exception as e:\nraise TemplatingException(\nf\"Error when running post script from .itmpl.py: {e}\"\n) from e\n</code></pre>"},{"location":"reference/templating/#itmpl.templating.template_directory","title":"template_directory","text":"<pre><code>template_directory(\ndir_path,\nvariables,\nignore_undefined=False,\nexclude=None,\n)\n</code></pre> <p>Template the contents of a directory using Jinja. Both file contents and filenames are templated.</p> Source code in <code>itmpl/templating.py</code> <pre><code>def template_directory(\ndir_path: Path,\nvariables: Dict[str, Any],\nignore_undefined: bool = False,\nexclude: Optional[List[str]] = None,\n) -&gt; None:\n\"\"\"Template the contents of a directory using Jinja. Both file contents and\n    filenames are templated.\"\"\"\ndirectories_to_rename = []\nexclusions = []\nif exclude:\nfor pattern in exclude:\nexclusions.extend([p.resolve() for p in dir_path.glob(pattern)])\nfor root, dirs, files in os.walk(dir_path):\n# Ignore directories that are in the exclude list\nroot = Path(root).resolve()\nif root in exclusions:\ncontinue\nfor directory in dirs:\nif root / directory in exclusions:\ncontinue\ndirectories_to_rename.append(root / directory)\nfor file in files:\nfile_path = root / file\nif file_path in exclusions:\ncontinue\n# Ignore .itmpl files\nif file_path.name.startswith(\".itmpl\"):\ncontinue\n# Template the file's contents\ntry:\ncontents_template = jinja2.Template(\nPath(file_path).read_text(),\nundefined=(\nIgnoreUndefined if ignore_undefined else jinja2.StrictUndefined\n),\nkeep_trailing_newline=True,\n)\nexcept UnicodeDecodeError:\n# Not a unicode file, so skip it\ncontinue\nrendered = contents_template.render(**variables)\nPath(file_path).write_text(rendered)\n# Rename the file\nfilename_template = jinja2.Template(file)\nrendered = filename_template.render(**variables)\nfile_path.rename(root / rendered)\n# Rename directories\n# Note: we have to reverse the list of directories to rename because\n# otherwise we might rename a parent directory, and then try to rename its\n# children using an incorrect path.\nfor directory in reversed(directories_to_rename):\nroot = directory.parent\ndirname_template = jinja2.Template(directory.name)\nrendered = dirname_template.render(**variables)\ndirectory.rename(root / rendered)\n</code></pre>"},{"location":"reference/tree_utils/","title":"tree_utils","text":""},{"location":"reference/tree_utils/#itmpl.tree_utils.find_duplicates","title":"find_duplicates","text":"<pre><code>find_duplicates(source, destination, ignore=None)\n</code></pre> <p>Find all the files in the destination directory that are present in the source directory. Unlike shutil.copytree, this function will not overwrite existing files and will create the destination directory if it does not exist.</p> Source code in <code>itmpl/tree_utils.py</code> <pre><code>def find_duplicates(\nsource: Path,\ndestination: Path,\nignore: Optional[Callable[[Path], bool]] = None,\n):\n\"\"\"Find all the files in the destination directory that are present in the\n    source directory. Unlike shutil.copytree, this function will not overwrite\n    existing files and will create the destination directory if it does not\n    exist.\n    \"\"\"\nignore = ignore or (lambda p: False)\nfor item in source.iterdir():\nif ignore(item):\n# Item is ignored\ncontinue\nelif not (destination / item.name).exists():\n# Item does not exist in destination\ncontinue\nelif item.is_dir():\n# Item is a directory, so recurse\nyield from find_duplicates(item, destination / item.name)\nelif (destination / item.name).exists():\n# Item is a file and exists in destination\nyield destination / item.name\n</code></pre>"},{"location":"reference/tree_utils/#itmpl.tree_utils.copy_tree","title":"copy_tree","text":"<pre><code>copy_tree(source, destination, ignore=None)\n</code></pre> <p>Copy a tree of files from source to destination. Unlike shutil.copytree, this function will not overwrite existing files and will create the destination directory if it does not exist.</p> Source code in <code>itmpl/tree_utils.py</code> <pre><code>def copy_tree(\nsource: Path,\ndestination: Path,\nignore: Optional[Callable[[Path], bool]] = None,\n):\n\"\"\"Copy a tree of files from source to destination. Unlike shutil.copytree,\n    this function will not overwrite existing files and will create the\n    destination directory if it does not exist.\n    \"\"\"\nignore = ignore or (lambda p: False)\nfor item in source.iterdir():\nif ignore(item):\ncontinue\nelif item.is_dir():\ncopy_tree(item, destination / item.name)\nelse:\ndestination.mkdir(parents=True, exist_ok=True)\nshutil.copy2(item, destination / item.name)\n</code></pre>"},{"location":"reference/tree_utils/#itmpl.tree_utils.recursive_delete","title":"recursive_delete","text":"<pre><code>recursive_delete(directory, glob)\n</code></pre> <p>Delete all files in a directory matching a glob.</p> Source code in <code>itmpl/tree_utils.py</code> <pre><code>def recursive_delete(directory: Path, glob: str) -&gt; None:\n\"\"\"Delete all files in a directory matching a glob.\"\"\"\nfor file in directory.rglob(glob):\nif file.is_file():\nfile.unlink()\nelse:\nshutil.rmtree(file)\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#itmpl.utils.import_external_module","title":"import_external_module","text":"<pre><code>import_external_module(module_path)\n</code></pre> <p>Import a module from an external path.</p> Source code in <code>itmpl/utils.py</code> <pre><code>def import_external_module(module_path: Path) -&gt; ModuleType:\n\"\"\"Import a module from an external path.\"\"\"\nspec = importlib.util.spec_from_file_location(\"itmpl\", module_path)\nif spec is None:\nraise ValueError(f\"No module found at path: {module_path}\")\nmodule = importlib.util.module_from_spec(spec)\nif spec.loader is None:\nraise ValueError(f\"No loader found for module: {module_path}\")\ntry:\nspec.loader.exec_module(module)\nexcept FileNotFoundError:\nraise ValueError(f\"No module found at path: {module_path}\")\nreturn module\n</code></pre>"},{"location":"reference/utils/#itmpl.utils.construct_table_from_templates","title":"construct_table_from_templates","text":"<pre><code>construct_table_from_templates(templates)\n</code></pre> <p>Construct a Rich table from a list of templates.</p> Source code in <code>itmpl/utils.py</code> <pre><code>def construct_table_from_templates(\ntemplates: Iterable[Tuple[Path, ItmplToml]],\n) -&gt; Table:\n\"\"\"Construct a Rich table from a list of templates.\"\"\"\ntable = Table(show_header=True, header_style=\"bold\")\ntable.add_column(\"Template\", justify=\"left\", no_wrap=True, header_style=\"blue\")\ntable.add_column(\"Description\")\ntable.add_column(\"Requirements\")\nfor template, toml_obj in templates:\ntable.add_row(\ntemplate.name,\ntoml_obj.metadata.template_description,\n\", \".join(toml_obj.metadata.template_requirements),\n)\nreturn table\n</code></pre>"},{"location":"reference/utils/#itmpl.utils.install_dependencies","title":"install_dependencies","text":"<pre><code>install_dependencies(dependencies)\n</code></pre> <p>Install dependencies.</p> Source code in <code>itmpl/utils.py</code> <pre><code>def install_dependencies(dependencies: List[str]):\n\"\"\"Install dependencies.\"\"\"\nsubprocess.check_call(\n[sys.executable, \"-m\", \"pip\", \"install\", *dependencies],\n)\n</code></pre>"},{"location":"reference/utils/#itmpl.utils.get_current_year","title":"get_current_year","text":"<pre><code>get_current_year()\n</code></pre> <p>Get the current year.</p> Source code in <code>itmpl/utils.py</code> <pre><code>def get_current_year() -&gt; str:\n\"\"\"Get the current year.\"\"\"\nreturn str(datetime.now().year)\n</code></pre>"},{"location":"reference/utils/#itmpl.utils.get_current_datetime","title":"get_current_datetime","text":"<pre><code>get_current_datetime()\n</code></pre> <p>Get the current datetime.</p> Source code in <code>itmpl/utils.py</code> <pre><code>def get_current_datetime() -&gt; str:\n\"\"\"Get the current datetime.\"\"\"\nreturn str(datetime.now().isoformat(timespec=\"seconds\"))\n</code></pre>"}]}